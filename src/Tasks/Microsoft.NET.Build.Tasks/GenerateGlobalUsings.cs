// Copyright (c) .NET Foundation and contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.Build.Framework;

namespace Microsoft.NET.Build.Tasks
{
    public sealed class GenerateGlobalUsings : TaskBase
    {
        [Required]
        public ITaskItem[] Usings { get; set; }

        [Required]
        public ITaskItem OutputFile { get; set; }

        protected override void ExecuteCore()
        {
            if (Usings.Length == 0)
            {
                return;
            }

            var usings = Usings.Select(UsingInfo.Read)
                .OrderBy(static k => k, UsingInfoComparer.Instance)
                .Distinct(UsingInfoComparer.Instance);

            StringBuilder builder = new();
            builder.AppendLine("// <auto-generated/>");
            foreach (var @using in usings)
            {
                builder.Append("global using ");

                if (@using.Static)
                {
                    builder.Append("static ");
                }

                if (!string.IsNullOrEmpty(@using.Alias))
                {
                    builder.Append(@using.Alias)
                        .Append(" = ");
                }

                builder.Append("global::")
                    .Append(@using.Namespace)
                    .Append(';')
                    .AppendLine();
            }

            var contentToWrite = builder.ToString();
            var outputFilePath = Path.GetFullPath(OutputFile.ItemSpec);
            if (File.Exists(outputFilePath))
            {
                var existing = File.ReadAllText(outputFilePath);

                if (string.Equals(existing, contentToWrite, StringComparison.Ordinal))
                {
                     Log.LogMessage(MessageImportance.Low, Strings.SkippingUnchangedFile, OutputFile.ItemSpec);
                    return;
                }
            }

            File.WriteAllText(outputFilePath, contentToWrite);
        }

        private readonly struct UsingInfo
        {
            public static UsingInfo Read(ITaskItem taskItem)
            {
                return new UsingInfo(
                    taskItem.ItemSpec,
                    taskItem.GetBooleanMetadata("Static") == true,
                    taskItem.GetMetadata("Alias"));
            }

            private UsingInfo(string @namespace, bool @static, string alias)
            {
                Namespace = @namespace;
                Static = @static;
                Alias = alias;
            }

            public string Namespace { get; }
            public bool Static { get; }
            public string Alias { get; }
        }

        private sealed class UsingInfoComparer : IComparer<UsingInfo>, IEqualityComparer<UsingInfo>
        {
            public static readonly UsingInfoComparer Instance = new();

            public int Compare(UsingInfo x, UsingInfo y)
            {
                var @static = x.Static.CompareTo(y.Static);
                if (@static != 0)
                {
                    return @static;
                }

                var alias = x.Alias.CompareTo(y.Alias);
                if (alias != 0)
                {
                    return alias;
                }

                return StringComparer.Ordinal.Compare(x.Namespace, y.Namespace);
            }

            public bool Equals(UsingInfo x, UsingInfo y)
            {
                return Compare(x, y) == 0;
            }

            public int GetHashCode(UsingInfo obj)
            {
                return StringComparer.Ordinal.GetHashCode(obj.Namespace);
            }
        }
    }
}
